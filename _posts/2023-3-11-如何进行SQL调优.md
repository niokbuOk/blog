## 索引失效的问题如何排查

### 背景

一般在慢SQL发生的时候需要考虑是否存在索引失效的问题。

### 具体做法

###### 第一步

找到要分析的SQL语句，然后使用explain查看执行计划。主要关注type，key，extra这三个字段。

###### 第二步

理想情况下走索引是以下情况：

首先，key一定有值，不能是NULL

其次，type应该是ref，eq_ref，range，const等着几个

还有，extra 是null，using index， using index condition都是可以。

###### 第三步

如果通过执行计划发现一条SQL没有走索引，比如type = ALL， key = NULL， extra = Using where

走不走索引，走哪个索引其实都是Mysql优化器决定的。

###### 第四步

如果没有走索引那么有以下几种情况导致的：

1. 没有正确的创建索引: 当查询语句的where条件中的字段，没有创建索引，或者不符合最左前缀匹配，或者没有正确的创建索引。
2. 索引区分度不够:如果区分度不高，那么可能不会走索引，因为这种情况下走索引的效率不高。
3. 表太小： 当表的数据不够多，优化器认为走全表扫描成本也不高，也可能不走索引。
4. 查询语句中，索引字段使用了函数，类型不一致导致索引失效。

###### 第五步

具体解决:

1. 如果没有正确创建索引，或者索引不符合最左前缀匹配。那就根据sql语句创建合适的索引，没有符合最左前缀就调整一下索引或者修改SQL语句。
2. 如果索引的区分度不高的话，那么就考虑换一个索引字段。
3. 如果表太小，这种情况没必要优化，因为影响不大。
4. 排查具体的失效原因，然后针对性的调整sql语句就行了。
   
###### 附加内容

1. 失效的栗子：
2. where age + 1 = 12;   不走索引的
3. where age = 12 - 1 走索引的
4. where YEAR(create_time) = 2022 使用了函数不走索引
5. name = “yellow” and age > 18  这是走索引的
6. name = “yellow” OR age > 18 不走索引，因为OR 存在一边 <>都不走索引
7. like %abc  不走索引  like不能以%开头
8. name = 1 不走索引，如果name是varchar 但是1是int 其实会使用隐式函数转换
9. where name is not null   is not null 索引失效
10. order by age 如果数据量很小，可能直接在内存中进行排序，而不走索引。
11. in  选项较多的时候，不走索引
